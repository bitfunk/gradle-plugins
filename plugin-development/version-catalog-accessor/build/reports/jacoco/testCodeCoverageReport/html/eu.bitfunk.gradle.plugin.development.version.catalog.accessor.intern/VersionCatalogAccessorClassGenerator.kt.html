<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VersionCatalogAccessorClassGenerator.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">version-catalog-accessor</a> &gt; <a href="index.source.html" class="el_package">eu.bitfunk.gradle.plugin.development.version.catalog.accessor.intern</a> &gt; <span class="el_source">VersionCatalogAccessorClassGenerator.kt</span></div><h1>VersionCatalogAccessorClassGenerator.kt</h1><pre class="source lang-java linenums">/*
 * ISC License
 *
 * Copyright (c) 2022. Wolf-Martell Montw√© (bitfunk)
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

package eu.bitfunk.gradle.plugin.development.version.catalog.accessor.intern

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier.OVERRIDE
import com.squareup.kotlinpoet.KModifier.PRIVATE
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import eu.bitfunk.gradle.plugin.development.version.catalog.accessor.intern.InternalContract.Mapper
import eu.bitfunk.gradle.plugin.development.version.catalog.accessor.intern.model.Catalog
import eu.bitfunk.gradle.plugin.development.version.catalog.accessor.intern.model.CatalogEntry
import eu.bitfunk.gradle.plugin.development.version.catalog.accessor.intern.model.CatalogEntry.Bundles
import eu.bitfunk.gradle.plugin.development.version.catalog.accessor.intern.model.CatalogEntry.Libraries
import eu.bitfunk.gradle.plugin.development.version.catalog.accessor.intern.model.CatalogEntry.Plugins
import eu.bitfunk.gradle.plugin.development.version.catalog.accessor.intern.model.CatalogEntry.Versions
import eu.bitfunk.gradle.plugin.development.version.catalog.accessor.intern.model.Node
import org.gradle.api.Project
import org.gradle.api.artifacts.VersionCatalog
import kotlin.reflect.KClass

<span class="pc" id="L39">internal class VersionCatalogAccessorClassGenerator(</span>
<span class="pc" id="L40">    private val packageName: String = &quot;&quot;,</span>
<span class="pc" id="L41">    private val baseName: String = &quot;&quot;,</span>
<span class="pc" id="L42">    private val classBaseName: String = &quot;&quot;,</span>
<span class="fc" id="L43">    private val mapper: Mapper,</span>
) : InternalContract.Generator.VersionCatalogAccessorClass {

    override fun generate(catalog: Catalog): TypeSpec {
<span class="fc" id="L47">        val libraryNodes = mapper.map(catalog.libraries.items)</span>

<span class="fc" id="L49">        return TypeSpec.classBuilder(classBaseName + Generator.CLASS_NAME)</span>
<span class="fc" id="L50">            .primaryConstructor(</span>
<span class="fc" id="L51">                FunSpec.constructorBuilder()</span>
<span class="fc" id="L52">                    .addParameter(Generator.ACCESSOR_PROPERTY_NAME_PROJECT, Project::class)</span>
<span class="fc" id="L53">                    .build(),</span>
<span class="fc" id="L54">            ).addProperty(</span>
<span class="fc" id="L55">                PropertySpec.builder(Generator.ACCESSOR_PROPERTY_NAME_PROJECT, Project::class)</span>
<span class="fc" id="L56">                    .initializer(Generator.ACCESSOR_PROPERTY_NAME_PROJECT)</span>
<span class="fc" id="L57">                    .addModifiers(PRIVATE)</span>
<span class="fc" id="L58">                    .build(),</span>
            )
<span class="fc" id="L60">            .addSuperinterface(ClassName(packageName, Generator.NAME_LIBRARIES.titleCase()))</span>
<span class="fc" id="L61">            .addProperty(</span>
<span class="fc" id="L62">                PropertySpec.builder(&quot;versionCatalog&quot;, VersionCatalog::class.java)</span>
<span class="fc" id="L63">                    .getter(</span>
<span class="fc" id="L64">                        FunSpec.getterBuilder()</span>
<span class="fc" id="L65">                            .addStatement(</span>
<span class="fc" id="L66">                                &quot;return %L&quot;,</span>
<span class="fc" id="L67">                                &quot;project.extensions.getByType(VersionCatalogsExtension::class.java)\n&quot; +</span>
<span class="fc" id="L68">                                    &quot;    .named(\&quot;${baseName.titleUncase()}\&quot;)&quot;,</span>
                            )
<span class="fc" id="L70">                            .build(),</span>
                    )
<span class="fc" id="L72">                    .addModifiers(PRIVATE)</span>
<span class="fc" id="L73">                    .build(),</span>
            )
<span class="fc" id="L75">            .addProperty(generateRootProperty(Generator.NAME_VERSIONS, catalog.versions))</span>
<span class="fc" id="L76">            .addProperty(generateRootProperty(Generator.NAME_BUNDLES, catalog.bundles))</span>
<span class="fc" id="L77">            .addProperty(generateRootProperty(Generator.NAME_PLUGINS, catalog.plugins))</span>
<span class="fc" id="L78">            .addProperties(</span>
<span class="fc" id="L79">                generateProperties(</span>
<span class="fc" id="L80">                    catalog.libraries::class,</span>
<span class="fc" id="L81">                    libraryNodes,</span>
<span class="fc" id="L82">                    Generator.NAME_LIBRARIES.titleCase(),</span>
                ),
            )
<span class="fc" id="L85">            .addFunction(generateCatalogFindFunction(&quot;findVersion&quot;))</span>
<span class="fc" id="L86">            .addFunction(generateCatalogFindFunction(&quot;findLibrary&quot;))</span>
<span class="fc" id="L87">            .addFunction(generateCatalogFindFunction(&quot;findBundle&quot;))</span>
<span class="fc" id="L88">            .addFunction(generateCatalogFindFunction(&quot;findPlugin&quot;))</span>
<span class="fc" id="L89">            .build()</span>
    }

    private fun generateRootProperty(name: String, catalogEntry: CatalogEntry): PropertySpec {
<span class="fc" id="L93">        val className = ClassName(packageName, name.titleCase())</span>
<span class="fc" id="L94">        return PropertySpec.builder(name, className)</span>
<span class="fc" id="L95">            .initializer(&quot;%L&quot;, generateRootImplementation(className, catalogEntry))</span>
<span class="fc" id="L96">            .build()</span>
    }

    private fun generateRootImplementation(className: ClassName, catalogEntry: CatalogEntry): TypeSpec {
<span class="fc" id="L100">        val nodes = mapper.map(catalogEntry.items)</span>
<span class="fc" id="L101">        val properties = generateProperties(catalogEntry::class, nodes, className.simpleName)</span>

<span class="fc" id="L103">        return TypeSpec.anonymousClassBuilder()</span>
<span class="fc" id="L104">            .addSuperinterface(className)</span>
<span class="fc" id="L105">            .addProperties(properties)</span>
<span class="fc" id="L106">            .build()</span>
    }

    private fun generateProperties(
        catalogType: KClass&lt;*&gt;,
        nodes: List&lt;Node&gt;,
        parentName: String,
    ): Iterable&lt;PropertySpec&gt; {
<span class="fc" id="L114">        val properties = mutableListOf&lt;PropertySpec&gt;()</span>

<span class="fc bfc" id="L116" title="All 2 branches covered.">        for (node in nodes) {</span>
<span class="fc bfc" id="L117" title="All 4 branches covered.">            val property = if (node.isGroup() &amp;&amp; node.isLeaf()) {</span>
<span class="fc" id="L118">                val name = &quot;$parentName.${node.name.titleCase()}&quot;</span>
<span class="fc" id="L119">                generateNodeProperty(</span>
<span class="fc" id="L120">                    catalogType,</span>
<span class="fc" id="L121">                    node,</span>
<span class="fc" id="L122">                    ClassName(packageName, name),</span>
<span class="fc" id="L123">                    ClassName(packageName, &quot;GroupLeaf&quot;),</span>
<span class="fc" id="L124">                    name,</span>
                )
<span class="fc bfc" id="L126" title="All 2 branches covered.">            } else if (node.isLeaf()) {</span>
<span class="fc" id="L127">                generateNodeProperty(</span>
<span class="fc" id="L128">                    catalogType,</span>
<span class="fc" id="L129">                    node,</span>
<span class="fc" id="L130">                    ClassName(packageName, &quot;VersionCatalogDependency.Leaf&quot;),</span>
<span class="fc" id="L131">                    ClassName(packageName, &quot;Leaf&quot;),</span>
<span class="fc" id="L132">                    parentName,</span>
                )
            } else {
<span class="fc" id="L135">                val name = &quot;$parentName.${node.name.titleCase()}&quot;</span>
<span class="fc" id="L136">                generateNodeProperty(</span>
<span class="fc" id="L137">                    catalogType,</span>
<span class="fc" id="L138">                    node,</span>
<span class="fc" id="L139">                    ClassName(packageName, name),</span>
<span class="fc" id="L140">                    ClassName(packageName, &quot;Group&quot;),</span>
<span class="fc" id="L141">                    name,</span>
                )
            }

<span class="fc" id="L145">            properties.add(property)</span>
        }

<span class="fc" id="L148">        return properties</span>
    }

    private fun generateNodeProperty(
        catalogType: KClass&lt;*&gt;,
        node: Node,
        className: ClassName,
        kClass: ClassName,
        parentName: String,
    ): PropertySpec {
<span class="fc" id="L158">        return PropertySpec.builder(node.name, className)</span>
<span class="fc" id="L159">            .addModifiers(OVERRIDE)</span>
<span class="fc" id="L160">            .initializer(&quot;%L&quot;, generateNodeImplementation(catalogType, node, className, kClass, parentName))</span>
<span class="fc" id="L161">            .build()</span>
    }

    private fun generateNodeImplementation(
        catalogType: KClass&lt;*&gt;,
        node: Node,
        className: ClassName,
        kClass: ClassName,
        parentName: String,
    ): TypeSpec {
<span class="fc" id="L171">        val nodeImplementation = TypeSpec.anonymousClassBuilder()</span>
<span class="fc" id="L172">            .addSuperinterface(className)</span>

<span class="fc bfc" id="L174" title="All 4 branches covered.">        if (kClass.simpleName == &quot;Leaf&quot; || kClass.simpleName == &quot;GroupLeaf&quot;) {</span>
<span class="fc" id="L175">            val getFunction = generateGetFunction(catalogType, node.path)</span>
<span class="fc" id="L176">            nodeImplementation.addFunction(getFunction)</span>
<span class="fc" id="L177">            val getStaticFunction = generateGetStaticFunction(catalogType, node.value)</span>
<span class="fc" id="L178">            nodeImplementation.addFunction(getStaticFunction)</span>
        }

<span class="fc bfc" id="L181" title="All 4 branches covered.">        if (node.children.isNotEmpty()) {</span>
<span class="fc" id="L182">            val properties = generateProperties(catalogType, node.children, parentName)</span>
<span class="fc" id="L183">            nodeImplementation.addProperties(properties)</span>
        }

<span class="fc" id="L186">        return nodeImplementation.build()</span>
    }

    private fun generateGetFunction(catalogType: KClass&lt;*&gt;, path: String): FunSpec {
<span class="fc" id="L190">        val functionName: String = when (catalogType) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            Versions::class -&gt; &quot;findVersion&quot;</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">            Libraries::class -&gt; &quot;findLibrary&quot;</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">            Bundles::class -&gt; &quot;findBundle&quot;</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">            Plugins::class -&gt; &quot;findPlugin&quot;</span>
<span class="nc" id="L195">            else -&gt; throw UnsupportedOperationException(&quot;$catalogType is not supported&quot;)</span>
        }

<span class="fc" id="L198">        return FunSpec.builder(FUNCTION_NAME_GET)</span>
<span class="fc" id="L199">            .addModifiers(OVERRIDE)</span>
<span class="fc" id="L200">            .returns(String::class)</span>
<span class="fc" id="L201">            .addStatement(&quot;return $functionName(\&quot;$path\&quot;)&quot;)</span>
<span class="fc" id="L202">            .build()</span>
    }

    private fun generateGetStaticFunction(catalogType: KClass&lt;*&gt;, value: String?): FunSpec {
<span class="fc" id="L206">        val statement: String = when (catalogType) {</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            Versions::class -&gt; &quot;return \&quot;$value\&quot;&quot;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            Libraries::class -&gt; THROW_UNSUPPORTED</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">            Bundles::class -&gt; THROW_UNSUPPORTED</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">            Plugins::class -&gt; THROW_UNSUPPORTED</span>
<span class="nc" id="L211">            else -&gt; throw UnsupportedOperationException(&quot;$catalogType is not supported&quot;)</span>
        }

<span class="fc" id="L214">        return FunSpec.builder(FUNCTION_NAME_GET_STATIC)</span>
<span class="fc" id="L215">            .addModifiers(OVERRIDE)</span>
<span class="fc" id="L216">            .returns(String::class)</span>
<span class="fc" id="L217">            .addStatement(statement)</span>
<span class="fc" id="L218">            .build()</span>
    }

    private fun generateCatalogFindFunction(name: String): FunSpec {
<span class="fc" id="L222">        return FunSpec.builder(name)</span>
<span class="fc" id="L223">            .addModifiers(PRIVATE)</span>
<span class="fc" id="L224">            .addParameter(&quot;name&quot;, String::class)</span>
<span class="fc" id="L225">            .returns(String::class)</span>
<span class="fc" id="L226">            .addStatement(&quot;try {&quot;)</span>
<span class="fc" id="L227">            .also {</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">                if (&quot;findVersion&quot; == name) {</span>
<span class="fc" id="L229">                    it.addStatement(&quot;    return versionCatalog.$name(name).get().requiredVersion&quot;)</span>
                } else {
<span class="fc" id="L231">                    it.addStatement(&quot;    return versionCatalog.$name(name).get().get().toString()&quot;)</span>
                }
<span class="fc" id="L233">            }</span>
<span class="fc" id="L234">            .addStatement(&quot;} catch (error: Throwable) {&quot;)</span>
<span class="fc" id="L235">            .addStatement(&quot;    throw NoSuchElementException(&quot;)</span>
<span class="fc" id="L236">            .addStatement(&quot;        \&quot;Can't $name accessor in $baseName.versions.toml: \$name\&quot;&quot;)</span>
<span class="fc" id="L237">            .addStatement(&quot;    )&quot;)</span>
<span class="fc" id="L238">            .addStatement(&quot;}&quot;)</span>
<span class="fc" id="L239">            .build()</span>
    }

    private companion object {
        const val FUNCTION_NAME_GET = &quot;get&quot;
        const val FUNCTION_NAME_GET_STATIC = &quot;getStatic&quot;

        const val THROW_UNSUPPORTED = &quot;throw UnsupportedOperationException(\n    \&quot;not yet implemented\&quot;\n)&quot;
    }
<span class="nc" id="L248">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>